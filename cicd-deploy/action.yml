name: 'CI/CD Deploy'

description: 'Deployment image via flux repository configured to appropriate GCP project'

inputs:
  release_name:
    description: 'Application name to use for release'
    required: true
  commit_hash:
    description: 'Application repository hash applied to release'
    required: true
  git_repo_branch:
    description: 'Application repository branch to release'
    required: true
  gh_auth_token:
    description: 'Github auth token for Flux deployment repository'
    required: true
  app_instance:
    description: 'Instance applied '
    required: false
    default: 'test'
  helm_chart_branch:
    description: 'Helm chart repository branch at the base of release'
    required: false
    default: 'master'
  helm_chart_name:
    description: 'Helm chart repository used to produce release manifest'
    required: false
    default: 'django-production-chart'
  helm_app_version:
    description: 'Helm application version used to produce release manifest'
    required: false
    default: '3.4.2'
  kubeval_version:
    description: 'Kubeval version used to lint kubernetes manifest'
    required: false
    default: 'latest'
  kubeval_skip_kinds:
    description: 'List of manifest objects for Kubeval to ignore'
    required: false
    default: 'ExternalSecret,ServiceMonitor'
  checkov_version:
    description: 'Checkov security policy manifest scanner version'
    required: false
    default: 'latest'
  checkov_skip_checks:
    description: 'Checkov security policy viloations to ignore'
    required: false
    # acceptable policy violations:
    #    CKV_K8S_21 - default namespace policy
    #    CKV_K8S_35 - secret files preferred over environment
    #    CKV_K8S_43 - image reference by digest
    #    CKV_K8S_106 - terminated-pod-gc-threshold set by MCI
    #    CKV_K8S_107 - kubernetes infrastructure profiling controlled by MCI
    default: 'CKV_K8S_21,CKV_K8S_35,CKV_K8S_43,CKV_K8S_106,CKV_K8S_107'
  prune_flux_repository:
    description: 'Prune release manifests'
    required: false
    default: true
  prune_flux_preserve_count:
    description: 'Number of flux repo branches to preserve when pruning'
    required: false
    default: 6
  prune_registry:
    description: 'Prune image registry'
    required: false
    default: false
  prune_registry_preserve_count:
    description: 'Number of images preserve when pruning registry'
    required: false
    default: 6

runs:
  using: 'composite'

  steps:
    - name: Deployment Context and Environment
      shell: bash
      run: |
        # master/main branch hardwired to prod GCP instance and "prod" app instance
        case ${{ inputs.git_repo_branch }} in
          main|master)
              APP_INSTANCE="prod"
              FLUX_INSTANCE="prod"
              GCP_PROJECT="uwit-mci-0011"
              FLUX_RELEASE_SUFFIX=""
              ;;
          *)
              APP_INSTANCE="${{ inputs.app_instance }}"
              FLUX_INSTANCE="dev"
              GCP_PROJECT="uwit-mci-0010"
              FLUX_RELEASE_SUFFIX=""
              if [ $APP_INSTANCE != "test" ]; then
                FLUX_RELEASE_SUFFIX="-${APP_INSTANCE}"
              fi
              ;;
        esac

        echo APP_INSTANCE="$APP_INSTANCE" >> $GITHUB_ENV

        APP_NAME=${{ inputs.release_name }}-prod-${APP_INSTANCE}
        echo "APP_NAME=$APP_NAME" >> $GITHUB_ENV

        echo "#####################################"
        echo "DEPLOY $APP_NAME in ${GCP_PROJECT}"
        echo "#####################################"

        FLUX_BASE_NAME=${{ inputs.release_name }}${FLUX_RELEASE_SUFFIX}

        MANIFEST_FILE_NAME=${FLUX_BASE_NAME}.yaml
        echo "MANIFEST_FILE_NAME=$MANIFEST_FILE_NAME" >> $GITHUB_ENV

        LOCAL_MANIFEST=${PWD}/$MANIFEST_FILE_NAME
        echo "LOCAL_MANIFEST=$LOCAL_MANIFEST" >> $GITHUB_ENV

        # helm chart
        HELM_CHART_LOCAL_DIR=${PWD}/${{ inputs.helm_chart_name }}
        echo "HELM_CHART_LOCAL_DIR=$HELM_CHART_LOCAL_DIR" >> $GITHUB_ENV

        # flux repository
        FLUX_REPO_BASE=gcp-flux-
        echo "FLUX_REPO_BASE=$FLUX_REPO_BASE" >> $GITHUB_ENV

        FLUX_REPO_OWNER=uw-it-aca
        echo "FLUX_REPO_OWNER=$FLUX_REPO_OWNER" >> $GITHUB_ENV

        FLUX_REPO_NAME=${FLUX_REPO_BASE}${FLUX_INSTANCE}
        FLUX_REPO_PATH=${FLUX_REPO_OWNER}/$FLUX_REPO_NAME
        echo "FLUX_REPO_PATH=$FLUX_REPO_PATH" >> $GITHUB_ENV

        FLUX_RELEASE_BRANCH=release/${FLUX_INSTANCE}/${FLUX_BASE_NAME}
        echo "FLUX_RELEASE_BRANCH=$FLUX_RELEASE_BRANCH" >> $GITHUB_ENV

        FLUX_RELEASE_BRANCH_NAME=${FLUX_RELEASE_BRANCH}/${{ inputs.commit_hash }}
        echo "FLUX_RELEASE_BRANCH_NAME=$FLUX_RELEASE_BRANCH_NAME" >> $GITHUB_ENV

        FLUX_RELEASE_MANIFEST=releases/${FLUX_INSTANCE}/$MANIFEST_FILE_NAME
        echo "FLUX_RELEASE_MANIFEST=$FLUX_RELEASE_MANIFEST" >> $GITHUB_ENV

        # local paths
        FLUX_LOCAL_DIR=${PWD}/$FLUX_REPO_NAME
        echo "FLUX_LOCAL_DIR=$FLUX_LOCAL_DIR" >> $GITHUB_ENV

        FLUX_PR_OUTPUT=${PWD}/pr-${FLUX_INSTANCE}-${{ inputs.release_name }}-${{ inputs.commit_hash }}.json
        echo "FLUX_PR_OUTPUT=$FLUX_PR_OUTPUT" >> $GITHUB_ENV


        # flux commit messages
        COMMIT_MESSAGE="Automated ${FLUX_INSTANCE} deploy of ${{ github.repository }}:${{ inputs.commit_hash }} build ${{ github.run_id }}"
        echo "COMMIT_MESSAGE=$COMMIT_MESSAGE" >> $GITHUB_ENV
        PULL_REQUEST_MESSAGE="Automated ${FLUX_INSTANCE} deploy of [${{ github.repository }}:${{ inputs.commit_hash }}](/${{ github.repository }}/commit/${{ inputs.commit_hash }})  Generated build [${{ github.run_id }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})"
        echo "PULL_REQUEST_MESSAGE=$PULL_REQUEST_MESSAGE" >> $GITHUB_ENV

    - name: Clone Helm Chart
      shell: bash
      run: >-
        export HELM_CHART_REPO_PATH="https://github.com/${FLUX_REPO_OWNER}/${{ inputs.helm_chart_name }}.git" &&
        echo "CLONE chart repository $HELM_CHART_REPO_PATH (${{ inputs.helm_chart_branch }})" &&
        git clone --depth 1 $HELM_CHART_REPO_PATH
        --branch ${{ inputs.helm_chart_branch }}
        ${HELM_CHART_LOCAL_DIR}

    - name: Generate App Manifest
      shell: bash
      run: >-
        export HELM_CHART_VALUES="/app/docker/${APP_INSTANCE}-values.yml" &&
        echo "GENERATE release manifest $MANIFEST_FILE_NAME using $HELM_CHART_VALUES" &&
        docker run -v ${PWD}:/app
        -v ${HELM_CHART_LOCAL_DIR}:/chart
        alpine/helm:${{ inputs.helm_app_version }}
        template ${APP_NAME} /chart
        --set-string "image.tag=${{ inputs.commit_hash }}"
        -f $HELM_CHART_VALUES > ${LOCAL_MANIFEST}

    - name: Validate Manifest
      shell: bash
      run: >-
        echo "VALIDATE generated manifest ${MANIFEST_FILE_NAME}" &&
        docker run -t -v ${PWD}:/app
        garethr/kubeval:${{ inputs.kubeval_version }}
        /app/${MANIFEST_FILE_NAME}
        --strict --skip-kinds "${{ inputs.kubeval_skip_kinds }}"

    - name: Security Policy Scan
      shell: bash
      run: |
        if [[ -n $(grep -e '^\s*securityContext\:.*$' "${LOCAL_MANIFEST}") ]]; then
          echo "SCAN generated manifest $MANIFEST_FILE_NAME against security policies"
          CHECKOV_IMAGE="bridgecrew/checkov:${{ inputs.checkov_version }}"
          docker run -t -v ${PWD}/:/app "$CHECKOV_IMAGE" --quiet --skip-check "${{ inputs.checkov_skip_checks }}" -f /app/${MANIFEST_FILE_NAME}
        else
          echo "Security Policy Scan Skipped: no context found"
        fi

    - name: Clone Flux Repository
      shell: bash
      run: |
        echo "::add-mask::${{ inputs.gh_auth_token }}"
        echo "CLONE flux repository ${FLUX_REPO_PATH}"

        git clone https://${{ inputs.gh_auth_token }}@github.com/${FLUX_REPO_PATH}.git --branch master ${FLUX_LOCAL_DIR}

    - name: Create Flux Release Branch
      shell: bash
      run: |
        echo "CREATE branch $FLUX_RELEASE_BRANCH_NAME, add $FLUX_RELEASE_MANIFEST"

        cd $FLUX_LOCAL_DIR
        git checkout -b ${FLUX_RELEASE_BRANCH_NAME}
        cp -p ${LOCAL_MANIFEST} ${FLUX_RELEASE_MANIFEST}
        git add ${FLUX_RELEASE_MANIFEST}
        git status

    - name: Commit Flux Release
      shell: bash
      run: |
        echo "::add-mask::${{ inputs.gh_auth_token }}"
        echo "COMMIT flux release $FLUX_RELEASE_BRANCH_NAME"

        cd $FLUX_LOCAL_DIR
        git config user.email "aca-it@uw.edu"
        git config user.name "uw-it-aca-tools"
        git commit -m "${COMMIT_MESSAGE}" ${FLUX_RELEASE_MANIFEST}
        git push origin ${FLUX_RELEASE_BRANCH_NAME}
        git status

    - name: Submit Flux Pull Release
      shell: bash
      run: |
        echo "::add-mask::${{ inputs.gh_auth_token }}"
        echo "SUBMIT $FLUX_RELEASE_BRANCH_NAME pull request"
        GITHUB_REPO_PULLS="https://api.github.com/repos/${FLUX_REPO_PATH}/pulls"
        PR_DATA=$(cat <<EOF
        {
          "title": "${COMMIT_MESSAGE}",
          "body": "${PULL_REQUEST_MESSAGE}",
          "head": "${FLUX_RELEASE_BRANCH_NAME}",
          "base": "master"
        }
        EOF
        )

        curl -H "Authorization: Token ${{ inputs.gh_auth_token }}" -H "Content-type: application/json" -X POST ${GITHUB_REPO_PULLS} >${FLUX_PR_OUTPUT} -d @- <<<${PR_DATA}
        FLUX_PULL_URL=$(jq '.html_url' ${FLUX_PR_OUTPUT})
        echo "FLUX_PULL_URL=$FLUX_PULL_URL" >> $GITHUB_ENV
        echo "SUBMITTED $FLUX_PULL_URL"

    - name: Merge Flux Pull Request
      env:
        GIT_REPO_BRANCH: ${{ inputs.git_repo_branch }}
      shell: bash
      run: |
        echo "::add-mask::${{ inputs.gh_auth_token }}"
        MERGE_DATA=$(cat <<EOF
        {
          "commit_title": "Automated merge of ${PULL_REQUEST_MESSAGE}",
          "commit_message": "Automated merge of ${PULL_REQUEST_MESSAGE}",
          "sha": $(jq '.head.sha' ${FLUX_PR_OUTPUT}),
          "merge_method": "merge"
        }
        EOF
        )

        if [[ $GIT_REPO_BRANCH =~ ^(main|master)$ ]]; then
          echo "Visit $FLUX_PULL_URL to merge manifest branch"
        else
          echo "MERGING ${FLUX_PULL_URL}"
          GITHUB_API_MERGE="$(jq --raw-output '.url' ${FLUX_PR_OUTPUT})/merge"
          curl -H "Authorization: Token ${{ inputs.gh_auth_token }}" -H "Content-type: application/json" -X PUT $GITHUB_API_MERGE -d @- <<<${MERGE_DATA}
        fi

    - name: Prune Flux Repository
      env:
        PRUNE_FLUX_REPOSITORY: ${{ inputs.prune_flux_repository }}
      shell: bash
      run: |
        cd $FLUX_LOCAL_DIR
        PRUNE_PRESERVE=$(expr 2 + ${{ inputs.prune_flux_preserve_count }})
        PRUNE_REFS=$(git for-each-ref --merged master --sort='-creatordate' --format='%(refname:strip=3)' "refs/remotes/origin/${FLUX_RELEASE_BRANCH}/" | tail -n +${PRUNE_PRESERVE})
        if [[ -n $PRUNE_REFS ]]; then
          if [[ $PRUNE_FLUX_REPOSITORY == 'true' ]] ; then
            echo "Pruning $(echo "${PRUNE_REFS}" | wc -l) stale manifest branches:"
            echo "${PRUNE_REFS}"
            echo "${PRUNE_REFS}" | xargs git push --delete origin
          else
            echo "The following branches are stale (${PRUNE_FLUX_REPOSITORY}):"
            echo "${PRUNE_REFS}"
          fi
        else
          echo "There are currently no stale branches to prune."
        fi

    - name: Prune Image Registry
      env:
        PRUNE_REGISTRY: ${{ inputs.prune_registry }}
      shell: bash
      run: |
        if [[ $PRUNE_REGISTRY == 'true' ]] ; then
          python3 - <<EOF
          import os
          import re
          import requests

          release_name = "${{ inputs.release_name }}"

          docker_jwt_token = None
          registry_host = "hub.docker.com"

          # environment variables
          #   GH_TOKEN - Github auth token
          #   REGISTRY_USER - Docker image registry owner
          #   REGISTRY_PASSWORD -  Docker image registry password

          def referenced_tags(release_name):
              preserve_tags = []
              for instance in ['dev', 'prod']:
                  branch_url = ('https://api.github.com/repos/{}/{}{}/'
                                'branches?page=1&per_page=100').format(
                      ${FLUX_REPO_OWNER}, ${FLUX_REPO_BASE}, instance)
                  branch_re = re.compile('^release/{}/{}(-[a-z]+)?/([a-f0-9]+)$'.format(
                      instance, release_name))

                  while branch_url:
                      response = requests.get(branch_url, headers={
                          "Authorization": "Token {}".format(os.getenv('GH_TOKEN')),
                          "Content-type": "application/vnd.github.v3+json"})
                      if response.status_code != requests.codes.ok:
                          print("failed to get branches ({}): {}".format(
                              response.status_code, branch_url))
                          exit(1)

                      for branch in response.json():
                          m = re.match(branch_re, branch['name'])
                          if m:
                              preserve_tags.append(m.group(2))

                      try:
                          branch_url = response.links['next']['url']
                      except KeyError:
                          branch_url = None

              return preserve_tags


          def registry_tags(release_name):
              registry_tags = []
              repo_tag_url = ('https://{}/v2/repositories/{}/{}/tags/'
                              '?page=1&page_size=100').format(
                                  registry_host, os.getenv('REGISTRY_USER'), release_name)
              while True:
                  raw = requests.get(repo_tag_url)
                  if raw.status_code != requests.codes.ok:
                      break

                  response = raw.json()
                  registry_tags.extend(response['results'])
                  if response['next']:
                      repo_tag_url = response['next']
                  else:
                      break

              registry_tags.sort(key=lambda x: x['last_updated'])
              return registry_tags


          def docker_jwt_access_token(release_name):
              global docker_jwt_token

              if docker_jwt_token is None:
                  docker_registry_url = 'https://{}/v2/users/login/'.format(registry_host)
                  headers = {'Content-Type': 'application/json'}
                  raw = requests.post(docker_registry_url, headers=headers, json={
                      "username": "{}".format(os.getenv('REGISTRY_USER')),
                      "password": "{}".format(os.getenv('REGISTRY_PASSWORD'))})
                  if raw.status_code != requests.codes.ok:
                      raise Exception("Cannot acquire token")

                  docker_jwt_token = raw.json()['token']

              return docker_jwt_token


          def delete_image_tag(release_name, tag):
              delete_url = 'https://{}/v2/repositories/{}/{}/tags/{}/'.format(
                  registry_host, os.getenv('REGISTRY_USER'),
                  release_name, tag['name'])
              headers = {'Authorization': 'JWT {}'.format(
                  docker_jwt_access_token(release_name))}
              response = requests.delete(delete_url, headers=headers)
              if response.status_code == requests.codes.no_content:
                  print("DELETED: {}".format(delete_url))

              raise Exception("failed to delete tag ({}): {}".format(
                  response.status_code, delete_url))


          if __name__ == '__main__':
              try:
                  flux_tags = referenced_tags(release_name)

                  if len(flux_tags) < 1:
                      raise Exception("Bailing because finding no referenced tags is weird.")

                  registry_tags = registry_tags(release_name)

                  for tag in registry_tags:
                      if tag['name'] in flux_tags:
                          flux_tags.remove(tag['name'])
                      else:
                          delete_image_tag(release_name, tag)
                          # just delete one while we're debugging
                          break

                  if len(flux_tags) > 0:
                      print("Flux references with no corresponding image: {}".format(flux_tags))
              except Exception as ex:
                  # pruning issues should never block deployment
                  print("Image pruning problem: {}".format(ex))

              raise SystemExit(0)
        EOF
        fi
