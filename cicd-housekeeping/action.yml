name: 'CI/CD Housekeeping'

description: 'Manage artifacts from build and deploy processses'

inputs:
# required inputs
  release_name:
    description: 'Application name to use for release'
    required: true
  gh_auth_token:
    description: 'Github auth token for Flux repository'
    required: true
  context:
    description: 'Configuration and derived values from deployment phase'
    required: true

# overridable defaults
  registry_host:
    description: 'Name of host containing image registry'
    default: 'gcr.io'
    required: false
  registry_owner:
    description: 'Owner id associated with registry'
    default: 'uwit-mci-axdd'
    required: false
  registry_user:
    description: 'Username for registry authentication'
    default: '_json_key'
    required: false
  registry_password:
    description: 'Password or token associated with username for registry authentication'
    default: ''
    required: false
  prune_grace_hours:
    description: 'Number of hours images without a flux reference remain in the registry'
    default: 168
    required: false
  prune_flux_repository:
    description: 'Actually prune release manifests'
    required: false
    default: true
  prune_flux_preserve_count:
    description: 'Number of flux repo branches to preserve when pruning'
    required: false
    default: 6
  prune_image_registry:
    description: 'Actually Prune docker image registry'
    required: false
    default: true

runs:
  using: 'composite'

  steps:
    - name: Setup Context
      shell: bash
      id: context
      run: |
        echo "::group::Context"

        function set_context {
          echo "${1^^}=${2}" >> $GITHUB_ENV
          echo "$1 = ${2}"
        }

        # pull in input.context
        while read -r -a kv; do
          set_context ${kv[0]} ${kv[1]}
        done <<< "$(echo ${{ inputs.context }} | jq -r 'keys[] as $k | "\($k) \(.[$k])"')"

        set_context flux_local_dir ${PWD}/${FLUX_REPO_NAME}

        echo "::endgroup::"

    - name: Prune Flux Repository
      shell: bash
      env:
        PRUNE_FLUX_REPOSITORY: ${{ inputs.prune_flux_repository }}
      run: |
        echo "::add-mask::${{ inputs.gh_auth_token }}"

        echo "Clone ${FLUX_REPO_PATH} repository"
        git clone https://${{ inputs.gh_auth_token }}@github.com/${FLUX_REPO_PATH}.git --branch master $FLUX_LOCAL_DIR
        cd $FLUX_LOCAL_DIR

        echo "Gather stale branches"
        PRUNE_PRESERVE=$(expr 2 + ${{ inputs.prune_flux_preserve_count }})
        PRUNE_REFS=$(git for-each-ref --merged master --sort='-creatordate' --format='%(refname:strip=3)' "refs/remotes/origin/${FLUX_RELEASE_BRANCH}/" | tail -n +${PRUNE_PRESERVE})

        if [[ -n $PRUNE_REFS ]]; then
          echo "Discovered stale ${FLUX_RELEASE_BRANCH} branches:"
          echo "${PRUNE_REFS}"
          if [[ $PRUNE_FLUX_REPOSITORY == 'true' ]]; then
            echo "WOULD git push delete origin"
            ## echo "${{ steps.references.outputs.prune_refs }}" | xargs git push --delete origin
          else
            echo "Skiping flux repo pruning step"
          fi
        else
          echo "There are currently no stale branches to prune."
        fi

    - name: Prune Image Registry
      shell: bash
      env:
        PRUNE_IMAGE_REGISTRY: ${{ inputs.prune_image_registry }}
      run: |
        if [[ $PRUNE_IMAGE_REGISTRY != 'true' ]]; then
          exit 0
        fi

        python3 - <<EOF
        import os
        import re
        import time
        import base64
        import requests
        from requests.auth import HTTPBasicAuth


        def flux_repository_tags(flux_repo_owner, flux_repo_base, flux_instances,
                                 release_name, auth_token):
            preserve_tags = []
            for instance in flux_instances:
                repo_name = "{}/{}{}".format(flux_repo_owner, flux_repo_base, instance)
                branch_url = ("https://api.github.com/repos/{}/branches"
                              "?page=1&per_page=100").format(repo_name)
                branch_re = re.compile('^release/{}/{}(-[a-z]+)?/([a-f0-9]+)$'.format(
                    instance, release_name))

                print("Collect branches in {} matching {}".format(
                    repo_name, branch_re))
                while branch_url:
                    raw = requests.get(branch_url, headers={
                        "Authorization": "Token {}".format(auth_token),
                        "Content-type": "application/vnd.github.v3+json"})
                    if raw.status_code != requests.codes.ok:
                        raise Exception("Failed to get branches ({}): {}".format(
                            raw.status_code, branch_url))

                    for branch in raw.json():
                        m = re.match(branch_re, branch['name'])
                        if m:
                            preserve_tags.append(m.group(2))

                    try:
                        branch_url = raw.links['next']['url']
                    except KeyError:
                        branch_url = None

            return preserve_tags


        def gcr_authorization(registry_host, registry_name, registry_token):
            registry_url = ("https://{}/v2/token?scope=repository"
                            ":{}:pull,push").format(registry_host, registry_name)
            headers = {'Content-Type': 'application/json'}
            raw = requests.get(registry_url, headers=headers,
                               auth=HTTPBasicAuth(
                                   "_json_key",
                                   base64.b64decode(registry_token).decode('ascii')))

            if raw.status_code != requests.codes.ok:
                raise Exception("Cannot acquire GCR auth token")

            return "Bearer {}".format(raw.json()['token'])


        def docker_authorization(registry_host, registry_user, registry_password):
            docker_registry_url = "https://{}/v2/users/login/".format(
                registry_host)
            headers = {'Content-Type': 'application/json'}
            raw = requests.post(docker_registry_url, headers=headers, json={
                "username": "{}".format(registry_user),
                "password": "{}".format(registry_password)})
            if raw.status_code != requests.codes.ok:
                raise Exception("Cannot acquire Docker auth token")

            return "JWT {}".format(raw.json()['token'])


        def docker_v2_tags(registry_host, registry_name):
            return "https://{}/v2/{}/tags/list".format(
                registry_host, registry_name)


        def docker_v2_manifests(registry_host, registry_name, item):
            return 'https://{}/v2/{}/manifests/{}'.format(
                registry_host, registry_name, item)


        def docker_v2_get(url, auth):
            print("GET: {}".format(url))
            headers = {'Accept': 'application/json',
                       'Authorization': auth}
            raw = requests.get(url, headers=headers)
            if raw.status_code == requests.codes.ok:
                return raw.json()

            print("GET failed ({}): {}".format(raw.status_code, raw.json()))


        def docker_v2_delete(url, auth):
            print("WOULD DELETE: {}".format(url))
            #headers = {'Authorization': auth}
            #raw = requests.delete(url, headers=headers)
            #if raw.status_code != requests.codes.accepted:
            #    print("DELETE failed ({}): {}".format(
            #        raw.status_code, raw.json()))


        def delete_registry_manifest(registry_host, registry_name, item, auth):
            manifest_url = docker_v2_manifests(registry_host, registry_name, item)
            docker_v2_delete(manifest_url, auth)


        def get_registry_manifest(registry_host, registry_name, auth):
            tags_url = docker_v2_tags(registry_host, registry_name)
            return docker_v2_get(tags_url, auth)['manifest']


        if __name__ == '__main__':
            release_name = os.getenv('RELEASE_NAME', 'prt')
            flux_repo_base = os.getenv('FLUX_REPO_BASE', 'gcp-flux-')
            flux_repo_owner = os.getenv('FLUX_REPO_OWNER', 'uw-it-aca')
            github_auth_token = "${{ inputs.gh_auth_token }}"
            registry_host = "${{ inputs.registry_host }}"
            registry_owner = "${{ inputs.registry_owner }}"
            registry_user = "${{ inputs.registry_user }}"
            registry_password = "${{ inputs.registry_password }}"
            prune_grace_hours = "${{ inputs.prune_grace_hours }}"
            flux_instances = ['dev', 'prod']
            registry_name = "{}/{}".format(registry_owner, release_name)

            try:
                print("Gather image tags for {} in {} flux repositories".format(
                    release_name, flux_instances))
                flux_tags = flux_repository_tags(
                    flux_repo_owner, flux_repo_base, flux_instances,
                    release_name, github_auth_token)

                if len(flux_tags) < 2:
                    raise Exception("Bail: finding no referenced tags is weird.")

                if registry_host.startswith('gcr'):
                    authorization = gcr_authorization(
                        registry_host, registry_name, registry_password)
                else:
                    authorization = docker_authorization(
                        registry_host, registry_user, registry_password)

                manifests = get_registry_manifest(
                    registry_host, registry_name, authorization)
                print("Gathered {} registry image references".format(len(manifests)))

                now = time.time()
                for sha, manifest in manifests.items():
                    # preserve tagged images matching tags found in the flux
                    # manifest repositories
                    if any(item in flux_tags for item in manifest['tag']):
                        print("Preserve flux referenced image tag: {}".format(
                            manifest['tag']))
                        continue

                    # preserve tagged images newer than the given threshold
                    hours = ((now - (float(manifest['timeCreatedMs'])/1000)) / 60 / 60)
                    if float(prune_grace_hours) > hours and len(manifest['tag']) > 0:
                        print("Preserving image {} less than {} hours old: {}".format(
                            manifest['tag'], prune_grace_hours, int(hours)))
                        continue

                    # tags must be deleted before the image can be deleted
                    for tag in manifest['tag']:
                        delete_registry_manifest(
                            registry_host, registry_name, tag, authorization)

                    delete_registry_manifest(
                        registry_host, registry_name, sha, authorization)
                    # raise Exception("Only one deletion per run while DEBUGGING")

            except Exception as ex:
                print("Image pruning problem: {}".format(ex))

            raise SystemExit(0)
        EOF
